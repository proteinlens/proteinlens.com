name: Deploy

on:
  push:
    branches: [ main ]
    paths-ignore:
      - '**.md'
      - 'docs/**'
      - 'specs/**'
      - '.gitignore'
      - 'LICENSE'
  workflow_dispatch:

permissions:
  contents: read
  id-token: write
  security-events: write

env:
  RESOURCE_GROUP: proteinlens-prod

concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ============================================================================
  # Detect Changes (determine what to deploy)
  # ============================================================================
  
  changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      backend: ${{ steps.filter.outputs.backend }}
      frontend: ${{ steps.filter.outputs.frontend }}
      admin: ${{ steps.filter.outputs.admin }}
      infra: ${{ steps.filter.outputs.infra }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6
      
      - name: Check for changes
        uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            backend:
              - 'backend/**'
              - '.github/workflows/deploy-api.yml'
            frontend:
              - 'frontend/**'
              - '.github/workflows/deploy-web.yml'
            admin:
              - 'admin/**'
              - '.github/workflows/deploy-admin.yml'
            infra:
              - 'infra/**'
              - '.github/workflows/infra.yml'
              - '.github/workflows/deploy.yml'

  # ============================================================================
  # STAGE 1: Pre-flight checks (run in PARALLEL for speed)
  # ============================================================================
  
  cleanup_artifacts:
    name: Cleanup Old Artifacts
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch'
    steps:
      - name: Delete old artifacts (keep last 5)
        uses: actions/github-script@v8
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const keepCount = 5;
            
            console.log(`ðŸ§¹ Cleaning up artifacts for ${owner}/${repo}, keeping last ${keepCount}...`);
            
            try {
              // Get all artifacts
              const artifacts = await github.paginate(
                github.rest.actions.listArtifactsForRepo,
                { owner, repo, per_page: 100 }
              );
              
              console.log(`Found ${artifacts.length} total artifacts`);
              
              // Group by name
              const byName = {};
              for (const artifact of artifacts) {
                if (!byName[artifact.name]) {
                  byName[artifact.name] = [];
                }
                byName[artifact.name].push(artifact);
              }
              
              // For each group, sort by date and delete old ones
              let deleted = 0;
              for (const [name, group] of Object.entries(byName)) {
                // Sort by created_at descending (newest first)
                group.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
                
                // Delete all except the newest keepCount
                const toDelete = group.slice(keepCount);
                for (const artifact of toDelete) {
                  try {
                    await github.rest.actions.deleteArtifact({
                      owner,
                      repo,
                      artifact_id: artifact.id
                    });
                    deleted++;
                    console.log(`âœ“ Deleted: ${artifact.name} (${artifact.id}) from ${artifact.created_at}`);
                  } catch (e) {
                    console.log(`âœ— Failed to delete ${artifact.id}: ${e.message}`);
                  }
                }
              }
              
              console.log(`\nâœ… Cleanup complete: deleted ${deleted} old artifacts`);
            } catch (error) {
              console.log(`âš ï¸ Artifact cleanup failed: ${error.message}`);
              // Don't fail the workflow if cleanup fails
            }

  secret_scan:
    name: Secret Scanning
    runs-on: ubuntu-latest
    needs: changes
    if: needs.changes.outputs.backend == 'true' || needs.changes.outputs.frontend == 'true' || needs.changes.outputs.admin == 'true' || needs.changes.outputs.infra == 'true'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 0  # Full history for comprehensive scan

      - name: Gitleaks Secret Scan
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITLEAKS_LICENSE: ${{ secrets.GITLEAKS_LICENSE }}

      - name: Check for hardcoded API keys
        run: |
          echo "Scanning for common secret patterns..."
          
          # OpenAI API key pattern
          if git grep -E 'sk-[A-Za-z0-9]{32,}' -- '*.ts' '*.js' '*.json' '*.yml' '*.yaml' 2>/dev/null; then
            echo "âŒ FAIL: OpenAI API key pattern detected"
            exit 1
          fi
          
          # Azure Cognitive Services key pattern
          if git grep -E '[0-9a-f]{32}' -- '*.ts' '*.js' 2>/dev/null | grep -i 'key'; then
            echo "âš ï¸ WARNING: Potential Azure key pattern detected"
            echo "Review matches above to ensure they are not secrets"
          fi
          
          # Generic API key assignments
          if git grep -E '(apiKey|api_key|API_KEY)\s*=\s*["\x27][A-Za-z0-9+/=]{20,}["\x27]' -- '*.ts' '*.js' 2>/dev/null; then
            echo "âŒ FAIL: Hardcoded API key assignment detected"
            exit 1
          fi
          
          echo "âœ… PASS: No obvious secrets detected"

      - name: Check for Key Vault reference usage
        run: |
          echo "Verifying Key Vault references in config files..."
          
          # Check GitHub Actions workflows use Key Vault patterns
          if grep -r 'AZURE_OPENAI_API_KEY' .github/workflows/ 2>/dev/null | grep -v '@Microsoft.KeyVault'; then
            echo "âš ï¸ WARNING: AZURE_OPENAI_API_KEY used without Key Vault reference"
          fi
          
          # Check Bicep files use Key Vault references
          if grep -r 'OPENAI.*API.*KEY' infra/bicep/ 2>/dev/null | grep -v 'KeyVault' | grep -v 'keyvault'; then
            echo "âš ï¸ WARNING: OpenAI key referenced in Bicep without Key Vault"
          fi
          
          echo "âœ… Key Vault reference check complete"

      - name: Validate script safety
        run: |
          echo "Checking scripts avoid logging secrets..."
          
          # Check scripts use silent modes
          if grep -E 'echo.*\$.*KEY' scripts/foundry-*.sh 2>/dev/null; then
            echo "âŒ FAIL: Script echoes variable that may contain key"
            exit 1
          fi
          
          # Verify --output none usage for sensitive commands
          if [ -f scripts/foundry-up.sh ] && ! grep -q 'keyvault secret set.*--output none' scripts/foundry-up.sh; then
            echo "âš ï¸ WARNING: Key Vault secret set may log output"
          fi
          
          echo "âœ… Script safety check complete"

  dns_gate:
    name: Production DNS Gate
    runs-on: ubuntu-latest
    # No dependencies - runs immediately in parallel with other pre-flight jobs
    outputs:
      ok: ${{ steps.gate.outputs.ok || steps.gateprod.outputs.ok }}
    steps:
      - name: Non-production branch
        if: github.ref != 'refs/heads/main'
        id: gate
        run: |
          echo "ok=true" >> "$GITHUB_OUTPUT"
          echo "âœ… Non-production branch; DNS gate passed"

      - name: Azure Login (OIDC)
        if: github.ref == 'refs/heads/main'
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Check Azure DNS zone
        if: github.ref == 'refs/heads/main'
        run: |
          ZONE="${{ vars.DNS_ZONE_NAME }}"
          [ -z "$ZONE" ] && ZONE="proteinlens.com"
          RG="${{ vars.AZURE_DNS_RESOURCE_GROUP }}"
          if [ -z "$RG" ]; then
            echo "âŒ AZURE_DNS_RESOURCE_GROUP not set"
            exit 1
          fi
          if az network dns zone show -g "$RG" -n "$ZONE" &>/dev/null; then
            echo "âœ… DNS zone '$ZONE' found"
          else
            echo "âŒ DNS zone '$ZONE' not found"
            exit 2
          fi

      - name: Set DNS gate output
        if: github.ref == 'refs/heads/main' && success()
        id: gateprod
        run: |
          echo "ok=true" >> "$GITHUB_OUTPUT"
          echo "âœ… Production DNS gate passed"

  # ============================================================================
  # STAGE 2: Infrastructure (waits for ALL pre-flight checks to pass)
  # ============================================================================

  infra:
    name: Provision Infra
    needs: [changes, secret_scan, dns_gate]
    if: needs.dns_gate.outputs.ok == 'true' && needs.changes.outputs.infra == 'true'
    uses: ./.github/workflows/infra.yml
    secrets: inherit
    with:
      environment: prod

  # ============================================================================
  # STAGE 3: Deploy apps (run in PARALLEL after infra)
  # ============================================================================

  deploy_backend:
    name: Deploy Backend
    needs: [changes, infra, dns_gate]
    if: |
      always() &&
      needs.changes.outputs.backend == 'true' &&
      (needs.infra.result == 'success' || needs.infra.result == 'skipped') &&
      needs.dns_gate.outputs.ok == 'true'
    uses: ./.github/workflows/deploy-api.yml
    secrets: inherit
    with:
      resource_group: proteinlens-prod
      functionapp_name: ${{ needs.infra.outputs.functionapp_name || 'proteinlens-api-prod' }}

  deploy_frontend:
    name: Deploy Frontend
    needs: [changes, infra, dns_gate]
    if: |
      always() &&
      needs.changes.outputs.frontend == 'true' &&
      (needs.infra.result == 'success' || needs.infra.result == 'skipped') &&
      needs.dns_gate.outputs.ok == 'true'
    uses: ./.github/workflows/deploy-web.yml
    secrets: inherit
    with:
      resource_group: proteinlens-prod
      staticwebapp_name: ${{ needs.infra.outputs.staticwebapp_name || 'proteinlens-web-prod' }}
      api_url: https://api.proteinlens.com

  deploy_admin:
    name: Deploy Admin Dashboard
    needs: [changes, infra, dns_gate]
    if: |
      always() &&
      needs.changes.outputs.admin == 'true' &&
      (needs.infra.result == 'success' || needs.infra.result == 'skipped') &&
      needs.dns_gate.outputs.ok == 'true' &&
      (needs.infra.outputs.admin_staticwebapp_name != '' || true)
    uses: ./.github/workflows/deploy-admin.yml
    secrets: inherit
    with:
      resource_group: proteinlens-prod
      staticwebapp_name: ${{ needs.infra.outputs.admin_staticwebapp_name || 'proteinlens-admin-prod' }}
      api_url: https://api.proteinlens.com

  # ============================================================================
  # STAGE 4: Health checks (after deploys complete)
  # ============================================================================

  health_check:
    name: Health Checks
    needs: [infra, deploy_backend, deploy_frontend, deploy_admin]
    if: always() && (needs.deploy_backend.result == 'success' || needs.deploy_frontend.result == 'success')
    runs-on: ubuntu-latest
    steps:
      - name: API health check (/api/health -> 200)
        run: |
          # Use infra output if available, otherwise fallback to default production URL
          INFRA_URL="${{ needs.infra.outputs.functionapp_url }}"
          if [ -z "$INFRA_URL" ] || [ "$INFRA_URL" = "null" ]; then
            URL="https://api.proteinlens.com/api/health"
          else
            URL="$INFRA_URL/api/health"
          fi
          echo "ðŸ” Testing API health: $URL"
          for i in $(seq 1 5); do
            code=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$URL" || true)
            echo "Attempt $i: HTTP $code"
            if [ "$code" = "200" ]; then
              echo "âœ… API health check passed"
              exit 0
            fi
            sleep 5
          done
          echo "âŒ API health check failed after 5 attempts"
          exit 1

      - name: Frontend check (index.html -> 200)
        run: |
          # Use infra output if available, otherwise fallback to default production URL
          INFRA_URL="${{ needs.infra.outputs.staticwebapp_url }}"
          if [ -z "$INFRA_URL" ] || [ "$INFRA_URL" = "null" ]; then
            URL="https://www.proteinlens.com"
          else
            URL="$INFRA_URL"
          fi
          echo "ðŸ” Testing frontend: $URL"
          for i in $(seq 1 5); do
            code=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$URL" || true)
            echo "Attempt $i: HTTP $code"
            if [ "$code" = "200" ]; then
              echo "âœ… Frontend check passed"
              exit 0
            fi
            sleep 5
          done
          echo "âŒ Frontend check failed after 5 attempts"
          exit 1

      - name: Admin Dashboard check (index.html -> 200)
        if: needs.infra.outputs.admin_staticwebapp_url != ''
        run: |
          URL="${{ needs.infra.outputs.admin_staticwebapp_url }}"
          echo "ðŸ” Testing admin dashboard: $URL"
          for i in $(seq 1 5); do
            code=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$URL" || true)
            echo "Attempt $i: HTTP $code"
            if [ "$code" = "200" ]; then
              echo "âœ… Admin dashboard check passed"
              exit 0
            fi
            sleep 5
          done
          echo "âš ï¸ Admin dashboard check failed (may not be deployed yet)"

  # ============================================================================
  # STAGE 5: Smoke Tests (verify full application functionality)
  # ============================================================================

  smoke_test:
    name: Smoke Tests
    needs: [infra, health_check]
    if: always() && needs.health_check.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Setup test environment
        run: |
          # Generate a unique test user ID for this run
          TEST_USER_ID="smoke-test-$(date +%s)-${{ github.run_id }}"
          echo "TEST_USER_ID=$TEST_USER_ID" >> $GITHUB_ENV
          echo "API_URL=${{ needs.infra.outputs.functionapp_url }}" >> $GITHUB_ENV
          echo "WEB_URL=${{ needs.infra.outputs.staticwebapp_url }}" >> $GITHUB_ENV
          echo "ðŸ§ª Test user ID: $TEST_USER_ID"

      - name: Test API - Liveness endpoint
        run: |
          echo "ðŸ” Testing liveness endpoint..."
          response=$(curl -s -w "\n%{http_code}" "$API_URL/api/health/liveness")
          code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | head -n -1)
          
          if [ "$code" = "200" ]; then
            echo "âœ… Liveness check passed"
            echo "$body" | jq . 2>/dev/null || echo "$body"
          else
            echo "âŒ Liveness check failed: HTTP $code"
            echo "$body"
            exit 1
          fi

      - name: Test API - Readiness endpoint
        run: |
          echo "ðŸ” Testing readiness endpoint..."
          response=$(curl -s -w "\n%{http_code}" "$API_URL/api/health/readiness")
          code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | head -n -1)
          
          if [ "$code" = "200" ]; then
            echo "âœ… Readiness check passed"
            echo "$body" | jq . 2>/dev/null || echo "$body"
          else
            echo "âŒ Readiness check failed: HTTP $code"
            echo "$body"
            exit 1
          fi

      - name: Test API - Upload URL generation
        run: |
          echo "ðŸ” Testing upload URL generation..."
          response=$(curl -s -w "\n%{http_code}" \
            -X POST "$API_URL/api/upload-url" \
            -H "Content-Type: application/json" \
            -H "x-user-id: $TEST_USER_ID" \
            -d '{"fileName":"smoke-test.jpg","fileSize":1024,"contentType":"image/jpeg"}')
          
          code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | head -n -1)
          
          if [ "$code" = "200" ]; then
            echo "âœ… Upload URL generation passed"
            # Verify response contains expected fields
            if echo "$body" | jq -e '.uploadUrl and .blobName and .expiresIn' > /dev/null 2>&1; then
              echo "âœ… Response structure valid"
              BLOB_NAME=$(echo "$body" | jq -r '.blobName')
              echo "BLOB_NAME=$BLOB_NAME" >> $GITHUB_ENV
            else
              echo "âŒ Response missing expected fields"
              echo "$body" | jq . 2>/dev/null || echo "$body"
              exit 1
            fi
          else
            echo "âŒ Upload URL generation failed: HTTP $code"
            echo "$body"
            exit 1
          fi

      - name: Test API - Usage endpoint
        run: |
          echo "ðŸ” Testing usage endpoint..."
          response=$(curl -s -w "\n%{http_code}" \
            "$API_URL/api/billing/usage" \
            -H "x-user-id: $TEST_USER_ID")
          
          code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | head -n -1)
          
          if [ "$code" = "200" ]; then
            echo "âœ… Usage endpoint passed"
            echo "$body" | jq . 2>/dev/null || echo "$body"
          else
            echo "âŒ Usage endpoint failed: HTTP $code"
            echo "$body"
            exit 1
          fi

      - name: Test API - Plans endpoint
        run: |
          echo "ðŸ” Testing plans endpoint..."
          response=$(curl -s -w "\n%{http_code}" "$API_URL/api/billing/plans")
          code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | head -n -1)
          
          if [ "$code" = "200" ]; then
            echo "âœ… Plans endpoint passed"
            # Verify we got plan data
            if echo "$body" | jq -e 'length > 0' > /dev/null 2>&1; then
              echo "âœ… Plans data returned"
              echo "$body" | jq '.[0]' 2>/dev/null || echo "$body"
            else
              echo "âš ï¸ No plans data returned (may be expected)"
            fi
          else
            echo "âŒ Plans endpoint failed: HTTP $code"
            echo "$body"
            exit 1
          fi

      - name: Test Frontend - Main page loads
        run: |
          echo "ðŸ” Testing frontend main page..."
          response=$(curl -s -w "\n%{http_code}" "$WEB_URL")
          code=$(echo "$response" | tail -n1)
          body=$(echo "$response" | head -n -1)
          
          if [ "$code" = "200" ]; then
            # Check for key content
            if echo "$body" | grep -q "ProteinLens"; then
              echo "âœ… Frontend loads with expected content"
            else
              echo "âš ï¸ Frontend loads but content may be unexpected"
            fi
          else
            echo "âŒ Frontend failed to load: HTTP $code"
            exit 1
          fi

      - name: Test Frontend - Static assets accessible
        run: |
          echo "ðŸ” Testing frontend static assets..."
          
          # Test manifest or common static assets
          for path in "/manifest.json" "/favicon.ico"; do
            response=$(curl -s -o /dev/null -w "%{http_code}" "$WEB_URL$path" || true)
            if [ "$response" = "200" ]; then
              echo "âœ… $path accessible"
            else
              echo "âš ï¸ $path returned HTTP $response (may be expected)"
            fi
          done

      - name: Test CORS headers
        run: |
          echo "ðŸ” Testing CORS configuration..."
          response=$(curl -s -I \
            -X OPTIONS "$API_URL/api/health" \
            -H "Origin: $WEB_URL" \
            -H "Access-Control-Request-Method: GET")
          
          if echo "$response" | grep -qi "access-control-allow"; then
            echo "âœ… CORS headers present"
            echo "$response" | grep -i "access-control"
          else
            echo "âš ï¸ CORS headers may not be configured (check if required)"
          fi

      - name: Generate smoke test report
        if: always()
        run: |
          echo "## ðŸ§ª Smoke Test Results" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "| Test | Status |" >> "$GITHUB_STEP_SUMMARY"
          echo "|------|--------|" >> "$GITHUB_STEP_SUMMARY"
          echo "| API Liveness | âœ… |" >> "$GITHUB_STEP_SUMMARY"
          echo "| API Readiness | âœ… |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Upload URL Generation | âœ… |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Usage Endpoint | âœ… |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Plans Endpoint | âœ… |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Frontend Load | âœ… |" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "**Test User ID:** \`$TEST_USER_ID\`" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "**Endpoints Tested:**" >> "$GITHUB_STEP_SUMMARY"
          echo "- API: $API_URL" >> "$GITHUB_STEP_SUMMARY"
          echo "- Web: $WEB_URL" >> "$GITHUB_STEP_SUMMARY"

  summary:
    name: Deployment Summary
    runs-on: ubuntu-latest
    needs: [secret_scan, dns_gate, infra, deploy_backend, deploy_frontend, deploy_admin, health_check, smoke_test]
    if: always()
    steps:
      - name: Summarize results
        run: |
          echo "## ðŸ“‹ Deployment Summary" >> "$GITHUB_STEP_SUMMARY"
          echo "| Component | Result |" >> "$GITHUB_STEP_SUMMARY"
          echo "|-----------|--------|" >> "$GITHUB_STEP_SUMMARY"
          echo "| Secret Scan | ${{ needs.secret_scan.result }} |" >> "$GITHUB_STEP_SUMMARY"
          echo "| DNS Gate | ${{ needs.dns_gate.outputs.ok || 'false' }} |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Infra | ${{ needs.infra.result }} |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Backend | ${{ needs.deploy_backend.result }} |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Frontend | ${{ needs.deploy_frontend.result }} |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Admin | ${{ needs.deploy_admin.result }} |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Health Checks | ${{ needs.health_check.result }} |" >> "$GITHUB_STEP_SUMMARY"
          echo "| Smoke Tests | ${{ needs.smoke_test.result }} |" >> "$GITHUB_STEP_SUMMARY"
          echo "" >> "$GITHUB_STEP_SUMMARY"
          echo "### Endpoints" >> "$GITHUB_STEP_SUMMARY"
          echo "- API: ${{ needs.infra.outputs.functionapp_url }}" >> "$GITHUB_STEP_SUMMARY"
          echo "- Web: ${{ needs.infra.outputs.staticwebapp_url }}" >> "$GITHUB_STEP_SUMMARY"
          echo "- Admin: ${{ needs.infra.outputs.admin_staticwebapp_url }}" >> "$GITHUB_STEP_SUMMARY"
