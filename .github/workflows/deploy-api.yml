name: Deploy Backend API

on:
  workflow_call:
    inputs:
      resource_group:
        description: 'Azure Resource Group'
        required: true
        type: string
      functionapp_name:
        description: 'Azure Function App Name'
        required: true
        type: string

permissions:
  contents: read
  id-token: write

env:
  NODE_VERSION: '20'

jobs:
  build-and-deploy:
    name: Build and Deploy
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: 'backend/package-lock.json'

      - name: Cache Prisma Client
        uses: actions/cache@v5
        id: prisma-cache
        with:
          path: |
            backend/node_modules/.prisma
            backend/node_modules/@prisma
          key: prisma-${{ runner.os }}-${{ hashFiles('backend/prisma/schema.prisma') }}

      - name: Cache Production Dependencies
        uses: actions/cache@v5
        id: prod-deps-cache
        with:
          path: backend/.deploy-cache
          key: prod-deps-${{ runner.os }}-${{ hashFiles('backend/package-lock.json') }}

      - name: Install dependencies
        run: |
          cd backend
          npm ci --prefer-offline
          echo "âœ… Dependencies installed"

      - name: Generate Prisma Client
        if: steps.prisma-cache.outputs.cache-hit != 'true'
        run: |
          cd backend
          npm run prisma:generate
          echo "âœ… Prisma client generated"

      - name: Cache TypeScript Build
        uses: actions/cache@v5
        id: ts-build-cache
        with:
          path: backend/dist
          key: ts-build-${{ runner.os }}-${{ hashFiles('backend/src/**/*.ts', 'backend/tsconfig.json') }}

      - name: Build TypeScript
        if: steps.ts-build-cache.outputs.cache-hit != 'true'
        run: |
          cd backend
          npm run build
          echo "âœ… TypeScript build completed"
      
      - name: Skip TypeScript build (cached)
        if: steps.ts-build-cache.outputs.cache-hit == 'true'
        run: echo "âœ… Using cached TypeScript build"

      # Unit tests run in PR workflow - skip during deploy for speed
      # - name: Run unit tests

      - name: Package Function App
        env:
          PROD_CACHE_HIT: ${{ steps.prod-deps-cache.outputs.cache-hit }}
        run: |
          cd backend
          # Validate host.json exists
          if [ ! -f "host.json" ]; then
            echo "âŒ host.json missing at backend/"
            exit 1
          fi
          # Ensure dist directory exists
          if [ ! -d "dist" ]; then
            echo "âŒ Build output directory not found"
            exit 1
          fi
          
          # Stage a deployable Functions app
          # Azure Functions v4 with ESM requires:
          # 1. Files at root level (not in dist/)
          # 2. package.json with "type": "module" and correct "main"
          # 3. All production dependencies in node_modules
          rm -rf .deploy && mkdir -p .deploy
          
          # Copy host.json
          cp host.json .deploy/
          
          # Copy Prisma schema and migrations
          cp -r prisma .deploy/prisma
          
          # Copy compiled JS files to ROOT (not in dist subfolder)
          cp -r dist/* .deploy/
          
          # Create production package.json
          cat package.json | jq 'del(.devDependencies) | .main = "index.js"' > .deploy/package.json
          
          # Use cached production dependencies if available
          if [ "$PROD_CACHE_HIT" = "true" ] && [ -d ".deploy-cache/node_modules" ]; then
            echo "ðŸ“¦ Using cached production dependencies..."
            cp -r .deploy-cache/node_modules .deploy/node_modules
          else
            echo "ðŸ“¦ Installing production dependencies..."
            cd .deploy
            npm install --omit=dev --ignore-scripts
            cd ..
            # Save to cache for next run
            rm -rf .deploy-cache && mkdir -p .deploy-cache
            cp -r .deploy/node_modules .deploy-cache/
          fi
          
          # Copy the already-generated Prisma client from the build step
          echo "ðŸ“¦ Copying generated Prisma client..."
          cp -r node_modules/.prisma .deploy/node_modules/.prisma
          cp -r node_modules/@prisma .deploy/node_modules/@prisma
          
          # Verify Prisma client was copied
          if [ ! -d ".deploy/node_modules/.prisma/client" ]; then
            echo "âŒ Prisma client not found - .prisma/client missing"
            exit 1
          fi
          echo "âœ… Prisma client copied"
          
          # Verify @azure/functions is present
          if [ ! -d ".deploy/node_modules/@azure/functions" ]; then
            echo "âŒ @azure/functions not found in node_modules"
            exit 1
          fi
          
          echo "âœ… Deployment folder prepared at backend/.deploy"

      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ vars.AZURE_TENANT_ID }}
          subscription-id: ${{ vars.AZURE_SUBSCRIPTION_ID }}

      - name: Verify Function App exists
        run: |
          RG="${{ inputs.resource_group }}"
          FA_NAME="${{ inputs.functionapp_name }}"
          echo "ðŸ” Checking Function App: $FA_NAME in RG: $RG"
          if az functionapp show --name "$FA_NAME" --resource-group "$RG" &> /dev/null; then
            echo "âœ… Function App found"
          else
            echo "âŒ Function App not found"
            exit 1
          fi

      - name: Run Database Migrations
        run: |
          RG="${{ inputs.resource_group }}"
          FA_NAME="${{ inputs.functionapp_name }}"
          
          echo "ðŸ”„ Fetching DATABASE_URL from Function App..."
          DATABASE_URL_RAW=$(az functionapp config appsettings list \
            --name "$FA_NAME" \
            --resource-group "$RG" \
            --query "[?name=='DATABASE_URL'].value" -o tsv)
          
          if [ -z "$DATABASE_URL_RAW" ]; then
            echo "âš ï¸ DATABASE_URL not found in Function App settings - skipping migrations"
            exit 0
          fi
          
          # Check if it's a Key Vault reference
          if [[ "$DATABASE_URL_RAW" == @Microsoft.KeyVault* ]]; then
            echo "ðŸ” DATABASE_URL is a Key Vault reference, resolving..."
            
            # Extract vault name and secret name using grep/sed instead of bash regex
            # Format: @Microsoft.KeyVault(SecretUri=https://xxx.vault.azure.net/secrets/yyy)
            if echo "$DATABASE_URL_RAW" | grep -q "SecretUri="; then
              SECRET_URI=$(echo "$DATABASE_URL_RAW" | sed -n 's/.*SecretUri=\([^)]*\).*/\1/p')
              VAULT_NAME=$(echo "$SECRET_URI" | sed -n 's|https://\([^.]*\)\.vault\.azure\.net.*|\1|p')
              SECRET_NAME=$(echo "$SECRET_URI" | sed -n 's|.*/secrets/\([^/)]*\).*|\1|p')
            elif echo "$DATABASE_URL_RAW" | grep -q "VaultName="; then
              VAULT_NAME=$(echo "$DATABASE_URL_RAW" | sed -n 's/.*VaultName=\([^;)]*\).*/\1/p')
              SECRET_NAME=$(echo "$DATABASE_URL_RAW" | sed -n 's/.*SecretName=\([^;)]*\).*/\1/p')
            else
              echo "âŒ Could not parse Key Vault reference format"
              echo "   Reference: $DATABASE_URL_RAW"
              exit 1
            fi
            
            if [ -z "$VAULT_NAME" ] || [ -z "$SECRET_NAME" ]; then
              echo "âŒ Could not extract vault name or secret name"
              echo "   Vault: $VAULT_NAME, Secret: $SECRET_NAME"
              exit 1
            fi
            
            echo "   Vault: $VAULT_NAME, Secret: $SECRET_NAME"
            
            # Fetch the actual secret value from Key Vault
            DATABASE_URL=$(az keyvault secret show \
              --vault-name "$VAULT_NAME" \
              --name "$SECRET_NAME" \
              --query "value" -o tsv)
            
            if [ -z "$DATABASE_URL" ]; then
              echo "âŒ Failed to fetch secret from Key Vault"
              exit 1
            fi
          else
            # Clean up the URL - remove any surrounding quotes and whitespace
            DATABASE_URL=$(echo "$DATABASE_URL_RAW" | tr -d '"' | tr -d "'" | xargs)
          fi
          
          # Validate URL format
          if [[ "$DATABASE_URL" != postgres://* ]] && [[ "$DATABASE_URL" != postgresql://* ]]; then
            echo "âŒ DATABASE_URL does not start with postgresql:// or postgres://"
            echo "   Value starts with: ${DATABASE_URL:0:15}..."
            exit 1
          fi
          
          echo "âœ… DATABASE_URL resolved and validated"
          
          # Run Prisma migrations
          cd backend
          export DATABASE_URL="$DATABASE_URL"
          
          echo "ðŸ“Š Checking migration status..."
          npx prisma migrate status || true
          
          echo "ðŸš€ Running database migrations..."
          npx prisma migrate deploy
          
          echo "âœ… Database migrations completed"

      - name: Verify Storage RBAC (informational)
        continue-on-error: true
        run: |
          RG="${{ inputs.resource_group }}"
          FA_NAME="${{ inputs.functionapp_name }}"
          
          FUNC_IDENTITY=$(az functionapp identity show --name "$FA_NAME" --resource-group "$RG" --query "principalId" -o tsv 2>/dev/null || echo "")
          STORAGE_NAME=$(az functionapp config appsettings list --name "$FA_NAME" --resource-group "$RG" --query "[?name=='AzureWebJobsStorage__accountName'].value" -o tsv 2>/dev/null || echo "")
          
          if [ -z "$FUNC_IDENTITY" ] || [ -z "$STORAGE_NAME" ]; then
            echo "âš ï¸ Could not check RBAC - identity or storage not found"
            exit 0
          fi
          
          STORAGE_ID=$(az storage account show --name "$STORAGE_NAME" --resource-group "$RG" --query "id" -o tsv 2>/dev/null || echo "")
          
          echo "ðŸ” Checking Storage RBAC for Function App identity: $FUNC_IDENTITY"
          ROLES=$(az role assignment list --assignee "$FUNC_IDENTITY" --scope "$STORAGE_ID" --query "[].roleDefinitionName" -o tsv 2>/dev/null || echo "")
          
          if echo "$ROLES" | grep -q "Storage Blob Data Owner"; then
            echo "âœ… Storage Blob Data Owner: assigned"
          else
            echo "âš ï¸ Storage Blob Data Owner: NOT assigned - Functions may fail"
          fi
          
          if echo "$ROLES" | grep -q "Storage Queue Data Contributor"; then
            echo "âœ… Storage Queue Data Contributor: assigned"
          else
            echo "âš ï¸ Storage Queue Data Contributor: NOT assigned - Functions may fail"
          fi
          
          if echo "$ROLES" | grep -q "Storage Table Data Contributor"; then
            echo "âœ… Storage Table Data Contributor: assigned"
          else
            echo "âš ï¸ Storage Table Data Contributor: NOT assigned - Functions may fail"
          fi

      - name: Configure Function App Settings
        run: |
          RG="${{ inputs.resource_group }}"
          FA_NAME="${{ inputs.functionapp_name }}"
          echo "âš™ï¸ Configuring Function App settings for Azure Functions v4 + ESM..."
          
          # Enable Azure Functions v4 Node.js programming model
          az functionapp config appsettings set \
            --name "$FA_NAME" \
            --resource-group "$RG" \
            --settings \
              "AzureWebJobsFeatureFlags=EnableWorkerIndexing" \
              "SCM_DO_BUILD_DURING_DEPLOYMENT=false" \
            --output none
          
          echo "âœ… Function App settings configured"
          
          # Brief wait for settings to propagate
          echo "â³ Waiting 5s for settings to propagate..."
          sleep 5

      - name: Create deployment zip
        run: |
          cd backend/.deploy
          zip -r ../deploy.zip .
          ls -la ../deploy.zip
          echo "âœ… Created deploy.zip"

      - name: Deploy to Azure Functions
        run: |
          RG="${{ inputs.resource_group }}"
          FA_NAME="${{ inputs.functionapp_name }}"
          echo "ðŸš€ Deploying to $FA_NAME in $RG"
          
          # Deploy with retry logic for SCM conflicts
          MAX_RETRIES=3
          RETRY_DELAY=30
          for i in $(seq 1 $MAX_RETRIES); do
            echo "ðŸ“¤ Deployment attempt $i of $MAX_RETRIES..."
            if az functionapp deployment source config-zip \
              --resource-group "$RG" \
              --name "$FA_NAME" \
              --src backend/deploy.zip \
              --timeout 300; then
              echo "âœ… Deployment completed successfully"
              break
            else
              if [ $i -lt $MAX_RETRIES ]; then
                echo "âš ï¸ Deployment failed, waiting ${RETRY_DELAY}s before retry..."
                sleep $RETRY_DELAY
                RETRY_DELAY=$((RETRY_DELAY * 2))
              else
                echo "âŒ Deployment failed after $MAX_RETRIES attempts"
                exit 1
              fi
            fi
          done

      - name: Warm up
        run: |
          RG="${{ inputs.resource_group }}"
          FA_NAME="${{ inputs.functionapp_name }}"
          
          echo "ðŸ”„ Restarting Function App to apply settings..."
          az functionapp restart --name "$FA_NAME" --resource-group "$RG"
          
          echo "â³ Waiting for Function App to start (15s)..."
          sleep 15

      - name: Verify Functions Deployed
        run: |
          RG="${{ inputs.resource_group }}"
          FA_NAME="${{ inputs.functionapp_name }}"
          
          # Get Function App URL
          FA_URL=$(az functionapp show \
            --name "$FA_NAME" \
            --resource-group "$RG" \
            --query "defaultHostName" -o tsv)
          
          echo "ðŸ” Function App URL: https://$FA_URL"
          
          # Test health endpoint
          echo "ðŸ¥ Testing health endpoint..."
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://$FA_URL/api/health" || echo "000")
          
          if [ "$HTTP_STATUS" = "200" ]; then
            echo "âœ… Health endpoint responding (HTTP $HTTP_STATUS)"
          elif [ "$HTTP_STATUS" = "404" ]; then
            echo "âš ï¸ Health endpoint not found (HTTP 404) - functions may still be loading"
          else
            echo "âš ï¸ Health endpoint returned HTTP $HTTP_STATUS"
          fi
          
          # List registered functions
          echo "ðŸ“‹ Checking registered functions..."
          FUNCTION_COUNT=$(az functionapp function list \
            --resource-group "$RG" \
            --name "$FA_NAME" \
            --query 'length(@)' -o tsv 2>/dev/null || echo "0")
          
          echo "Found $FUNCTION_COUNT functions"
          
          if [ "$FUNCTION_COUNT" -eq 0 ]; then
            echo "âš ï¸ No functions detected yet"
            echo "   This may indicate:"
            echo "   - Functions are still loading (cold start)"
            echo "   - Entry point configuration issue"
            echo "   - Check Azure Portal > Function App > Functions for details"
          else
            echo "âœ… Functions deployed successfully:"
            az functionapp function list --resource-group "$RG" --name "$FA_NAME" --query '[].name' -o tsv
          fi
