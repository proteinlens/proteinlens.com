// Prisma schema for ProteinLens meal analysis
// Constitution compliance: traceability, auditability, user data rights

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x", "debian-openssl-1.1.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ===========================================
// Enums for Billing (Feature 002)
// ===========================================

enum Plan {
  FREE
  PRO
}

enum SubscriptionStatus {
  active
  canceled
  past_due
  trialing
}

enum UsageType {
  MEAL_ANALYSIS
}

// ===========================================
// Enums for User Signup (Feature 010)
// ===========================================

enum ConsentType {
  TERMS_OF_SERVICE
  PRIVACY_POLICY
  MARKETING_EMAILS
}

enum SignupAttemptOutcome {
  SUCCESS
  VALIDATION_ERROR
  DUPLICATE_EMAIL
  RATE_LIMITED
  CAPTCHA_FAILED
  BREACH_PASSWORD
  NETWORK_ERROR
}

// ===========================================
// Enums for Admin Dashboard (Feature 012)
// ===========================================

enum AdminActionType {
  VIEW_USER_LIST
  VIEW_USER_DETAIL
  PLAN_OVERRIDE
  SUSPEND_USER
  REACTIVATE_USER
  EXPORT_USERS
  VIEW_AUDIT_LOG
}

enum OrganizationInviteStatus {
  PENDING
  ACCEPTED
  EXPIRED
  CANCELLED
}

// ===========================================
// Auth Event Type (Feature 013 - Self-managed Auth)
// ===========================================

enum AuthEventType {
  SIGNUP_SUCCESS
  SIGNUP_FAILED
  SIGNIN_SUCCESS
  SIGNIN_FAILED
  SIGNOUT
  EMAIL_VERIFIED
  PASSWORD_RESET_REQUESTED
  PASSWORD_RESET_SUCCESS
  SESSION_REVOKED
  PASSWORD_CHANGED
}

// ===========================================
// Auth Provider Type (Feature 010 - Self-managed Auth)
// ===========================================

enum AuthProvider {
  LOCAL       // Email + password
  GOOGLE      // Google OAuth
  MICROSOFT   // Microsoft OAuth
}

// ===========================================
// User Model (Extended for Billing + Signup)
// ===========================================

model User {
  id                    String              @id @default(uuid())
  
  // Email as primary identifier (unique for auth, optional for legacy users)
  email                 String?             @unique @db.VarChar(320)
  
  // Password auth (for LOCAL provider)
  passwordHash          String?             @db.VarChar(255)
  
  // OAuth fields (for social providers)
  authProvider          AuthProvider        @default(LOCAL)
  oauthProviderId       String?             @db.VarChar(255)  // Provider's user ID
  
  // Legacy field for backwards compatibility
  externalId            String?             @unique @db.VarChar(255)
  
  // Profile fields (Feature 010 - User Signup)
  firstName             String?             @db.VarChar(50)
  lastName              String?             @db.VarChar(50)
  organizationName      String?             @db.VarChar(100)
  phone                 String?             @db.VarChar(20)
  emailVerified         Boolean             @default(false)
  profileCompleted      Boolean             @default(false)
  
  // Stripe billing fields (Feature 002)
  stripeCustomerId      String?             @unique @db.VarChar(255)
  stripeSubscriptionId  String?             @db.VarChar(255)
  plan                  Plan                @default(FREE)
  subscriptionStatus    SubscriptionStatus?
  currentPeriodEnd      DateTime?
  
  // Timestamps
  createdAt             DateTime            @default(now())
  updatedAt             DateTime            @updatedAt
  
  // Feature 012: Admin Dashboard - Account Suspension
  suspended             Boolean             @default(false)
  suspendedAt           DateTime?
  suspendedReason       String?             @db.VarChar(500)
  suspendedBy           String?             @db.VarChar(255)  // Admin email who suspended
  
  // Relations
  usage                 Usage[]
  subscriptionEvents    SubscriptionEvent[]
  consentRecords        ConsentRecord[]
  refreshTokens         RefreshToken[]
  emailVerificationTokens EmailVerificationToken[]
  passwordResetTokens   PasswordResetToken[]
  authEvents            AuthEvent[]
  
  @@index([externalId])
  @@index([stripeCustomerId])
  @@index([plan])
  @@index([email])
  @@index([authProvider, oauthProviderId])
}

// ===========================================
// Refresh Token (Feature 010 - Self-managed Auth)
// ===========================================

model RefreshToken {
  id              String    @id @default(uuid())
  userId          String
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  tokenHash       String    @unique @db.VarChar(64)  // SHA-256 hash of token
  deviceInfo      String?   @db.VarChar(255)         // Browser/device identifier
  ipAddress       String?   @db.VarChar(45)
  
  expiresAt       DateTime
  revokedAt       DateTime?
  
  createdAt       DateTime  @default(now())
  
  @@index([userId])
  @@index([tokenHash])
  @@index([expiresAt])
}

// ===========================================
// Email Verification Token (Feature 010)
// ===========================================

model EmailVerificationToken {
  id              String    @id @default(uuid())
  userId          String
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  tokenHash       String    @unique @db.VarChar(64)  // SHA-256 hash
  
  expiresAt       DateTime  // 24 hours from creation
  usedAt          DateTime?
  
  createdAt       DateTime  @default(now())
  
  @@index([userId])
  @@index([tokenHash])
}

// ===========================================
// Password Reset Token (Feature 010)
// ===========================================

model PasswordResetToken {
  id              String    @id @default(uuid())
  userId          String
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  tokenHash       String    @unique @db.VarChar(64)
  
  expiresAt       DateTime  // 1 hour from creation
  usedAt          DateTime?
  
  createdAt       DateTime  @default(now())
  
  @@index([userId])
  @@index([tokenHash])
  @@index([suspended])
}

// ===========================================
// Consent Record (Feature 010 - User Signup)
// ===========================================

model ConsentRecord {
  id              String       @id @default(uuid())
  userId          String
  user            User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  consentType     ConsentType
  documentVersion String       @db.VarChar(20)  // e.g., "1.0.0", "2025-01-01"
  ipAddress       String       @db.VarChar(45)  // IPv4 or IPv6
  userAgent       String?      @db.VarChar(500)
  
  grantedAt       DateTime     @default(now())
  revokedAt       DateTime?    // Null if still valid
  
  @@unique([userId, consentType])  // One active consent per type per user
  @@index([userId])
  @@index([consentType])
  @@index([grantedAt])
}

// ===========================================
// Signup Attempt Audit Log (Feature 010)
// ===========================================

model SignupAttempt {
  id              String                @id @default(uuid())
  
  email           String                @db.VarChar(320)  // Attempted email (not linked to User)
  ipAddress       String                @db.VarChar(45)
  userAgent       String?               @db.VarChar(500)
  
  outcome         SignupAttemptOutcome
  failureReason   String?               @db.VarChar(200)  // Human-readable reason
  
  // Don't store: password, full form data (PII minimization)
  
  createdAt       DateTime              @default(now())
  
  @@index([email, createdAt])
  @@index([ipAddress, createdAt])
  @@index([outcome])
}

// ===========================================
// Auth Event Audit Log (Feature 013 - Self-managed Auth)
// ===========================================

model AuthEvent {
  id              String          @id @default(uuid())
  
  userId          String?         // NULL for failed signin with unknown email
  user            User?           @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  email           String          @db.VarChar(320)
  eventType       AuthEventType
  ipAddress       String          @db.VarChar(45)
  userAgent       String?         @db.VarChar(500)
  metadata        Json?           // Event-specific data (e.g., failureReason)
  
  createdAt       DateTime        @default(now())
  
  @@index([userId])
  @@index([eventType])
  @@index([createdAt])
  @@index([email, createdAt])
}

// ===========================================
// Organization Invite (Feature 010 - User Signup)
// ===========================================

model OrganizationInvite {
  id                String                   @id @default(uuid())
  
  // Invite token (unique, URL-safe)
  token             String                   @unique @db.VarChar(64)
  
  // Invited email
  email             String                   @db.VarChar(320)
  
  // Organization info
  organizationId    String                   @db.VarChar(255)
  organizationName  String                   @db.VarChar(100)
  
  // Inviter info
  invitedBy         String                   @db.VarChar(255)  // User ID who sent invite
  invitedByName     String?                  @db.VarChar(100)  // Display name for email
  
  // Status tracking
  status            OrganizationInviteStatus @default(PENDING)
  
  // Expiration and usage
  expiresAt         DateTime                 // Default: 7 days from creation
  usedAt            DateTime?                // When invite was accepted
  usedByUserId      String?                  @db.VarChar(255)  // User ID who accepted
  
  // Metadata
  createdAt         DateTime                 @default(now())
  updatedAt         DateTime                 @updatedAt
  
  @@index([token])
  @@index([email])
  @@index([organizationId])
  @@index([status, expiresAt])
}

// ===========================================
// Usage Tracking (Feature 002)
// ===========================================

model Usage {
  id        String    @id @default(uuid())
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  type      UsageType
  mealId    String?   @db.VarChar(255)  // Reference to MealAnalysis.id
  
  createdAt DateTime  @default(now())
  
  @@index([userId, createdAt])
  @@index([userId, type, createdAt])
}

// ===========================================
// Subscription Event Audit Log (Feature 002)
// ===========================================

model SubscriptionEvent {
  id            String    @id @default(uuid())
  userId        String?
  user          User?     @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  eventType     String    @db.VarChar(100)
  stripeEventId String    @unique @db.VarChar(255)
  eventData     Json
  
  processedAt   DateTime?
  createdAt     DateTime  @default(now())
  
  @@index([userId])
  @@index([eventType])
  @@index([stripeEventId])
}

// ===========================================
// Meal Analysis (Core Feature)
// ===========================================

model MealAnalysis {
  id              String   @id @default(uuid())
  userId          String   @db.VarChar(255)
  
  // Blob storage reference (Constitution Principle III: Blob-First Ingestion)
  blobName        String   @db.VarChar(500)
  blobUrl         String   @db.Text  // WITHOUT SAS token (permanent path)
  blobHash        String?  @db.VarChar(64)  // SHA-256 for caching (Principle VI)
  
  // Traceability (Constitution Principle IV)
  requestId       String   @db.Uuid
  
  // AI model metadata
  aiModel         String   @db.VarChar(100)  // e.g., "gpt-5.1-vision"
  aiResponseRaw   Json     // Original AI response (Principle V: schema-valid JSON)
  
  // Analysis results
  totalProtein    Decimal  @db.Decimal(6, 2)
  confidence      String   @db.VarChar(20)  // "high", "medium", "low"
  notes           String?  @db.Text
  
  // User corrections (Constitution Principle IV: maintain original + corrections)
  userCorrections Json?    // Stores user-edited values separately
  
  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Relations
  foods           Food[]
  
  // Indexes for performance
  @@index([userId, createdAt])
  @@index([blobHash])
  @@index([requestId])
}

model Food {
  id              String        @id @default(uuid())
  mealAnalysisId  String
  mealAnalysis    MealAnalysis  @relation(fields: [mealAnalysisId], references: [id], onDelete: Cascade)
  
  // Food details from AI
  name            String        @db.VarChar(200)
  portion         String        @db.VarChar(100)
  protein         Decimal       @db.Decimal(6, 2)
  
  // Order for display
  displayOrder    Int           @default(0)
  
  createdAt       DateTime      @default(now())
  
  @@index([mealAnalysisId])
}

// ===========================================
// Admin Audit Log (Feature 012 - Admin Dashboard)
// ===========================================
// Append-only log of all admin actions

model AdminAuditLog {
  id            String          @id @default(uuid())
  
  // Admin identity
  adminEmail    String          @db.VarChar(320)
  adminId       String?         @db.VarChar(255)  // External ID if available
  
  // Action details
  action        AdminActionType
  targetUserId  String?         @db.VarChar(255)  // User affected (if applicable)
  targetEmail   String?         @db.VarChar(320)  // Denormalized for search
  
  // Action metadata
  details       Json?           // Action-specific data (e.g., old plan, new plan)
  reason        String?         @db.VarChar(500)  // Admin-provided reason
  
  // Request context
  requestId     String          @db.Uuid
  ipAddress     String          @db.VarChar(45)   // IPv4 or IPv6
  userAgent     String?         @db.VarChar(500)
  
  // Timestamp (immutable - no updatedAt by design)
  createdAt     DateTime        @default(now())
  
  // Indexes for efficient querying
  @@index([adminEmail, createdAt])
  @@index([targetUserId, createdAt])
  @@index([action, createdAt])
  @@index([createdAt])
}
